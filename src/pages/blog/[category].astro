---
import BaseHead from '../../components/BaseHead.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { SITE_TITLE, CATEGORIES } from '../../consts';
import { getCollection } from 'astro:content';
import FormattedDate from '../../components/FormattedDate.astro';
import { Image } from 'astro:assets';
import Search from '../../components/Search.astro';

export async function getStaticPaths() {
  return CATEGORIES.map((cat) => ({
    params: { category: cat.slug },
    props: { categoryData: cat }, 
  }));
}

const { category } = Astro.params;
const { categoryData } = Astro.props;

// 1. Ë®ò‰∫ã„ÇíÂèñÂæó„Åó„Å¶„Åì„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÅÆ„Åø„Å´Áµû„ÇäËæº„Åø
const allPosts = await getCollection('blog');
const filteredPosts = allPosts
  .filter((post) => post.data.category === category)
  .sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// 2. SupabaseÊé•Á∂öÊÉÖÂ†±
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

let likesData = [];
try {
  const res = await fetch(`${supabaseUrl}/rest/v1/post_likes?select=slug,count`, {
    headers: { 'apikey': supabaseKey, 'Authorization': `Bearer ${supabaseKey}` }
  });
  likesData = await res.json();
} catch (e) {
  console.error("„ÅÑ„ÅÑ„Å≠„Éá„Éº„Çø„ÅÆÂèñÂæó„Å´Â§±Êïó:", e);
}

// 3. „ÅÑ„ÅÑ„Å≠Êï∞„Çí„Éû„Éº„Ç∏
const postsWithLikes = filteredPosts.map(post => {
  const match = likesData.find(l => l.slug === `/blog/${post.id}/`);
  return { ...post, likeCount: match ? match.count : 0 };
});

const pageTitle = `${categoryData.label} | ${SITE_TITLE}`;
---

<!doctype html>
<html lang="ja">
	<head>
		<BaseHead title={pageTitle} description={categoryData.description} />
		<style>
			:root {
				--accent: #0984e3;
				--accent-gradient: linear-gradient(135deg, #0984e3, #6c5ce7);
				--text-main: #1d1d1f;
				--text-sub: #86868b;
				--ui-bg: #f5f5f7;
			}
			main {
				width: 960px;
				max-width: calc(100% - 2em);
				margin: auto;
				padding: 2em 1em;
			}

			/* ‚ñº‚ñº‚ñº All Posts „Å®ÂÆåÂÖ®„Å´ÂêåÊúü„Åó„Åü„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ ‚ñº‚ñº‚ñº */
			.blog-dashboard {
				background: #ffffff;
				border: 1px solid rgba(0, 0, 0, 0.06);
				border-radius: 24px;
				padding: 2rem;
				margin-bottom: 4rem;
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.02);
			}

			.category-nav {
				display: flex;
				flex-wrap: wrap;
				gap: 0.8rem;
				justify-content: center;
				margin-bottom: 1.5rem;
			}
			.cat-link {
				text-decoration: none;
				padding: 0.5rem 1.2rem;
				border-radius: 50px;
				font-size: 0.9rem;
				font-weight: 600;
				color: var(--text-sub);
				background: var(--ui-bg);
				transition: all 0.2s ease;
			}
			.cat-link:hover { color: var(--accent); }
			.cat-link.active {
				background: var(--accent-gradient);
				color: white;
				box-shadow: 0 4px 15px rgba(9, 132, 227, 0.3);
			}

			.search-container {
				max-width: 500px;
				margin: 0 auto 2rem;
			}

			.sort-section {
				display: flex;
				justify-content: center;
				align-items: center;
				gap: 1.5rem;
				padding-top: 1.5rem;
				border-top: 1px solid #f2f2f2;
			}
			.sort-label {
				font-size: 0.75rem;
				font-weight: 800;
				color: #b2bec3;
				text-transform: uppercase;
				letter-spacing: 0.1em;
			}
			.sort-options {
				display: flex;
				gap: 1rem;
			}
			.sort-btn {
				border: none;
				background: transparent;
				padding: 4px 8px;
				font-size: 0.85rem;
				font-weight: 700;
				color: var(--text-sub);
				cursor: pointer;
				position: relative;
				transition: color 0.2s;
			}
			.sort-btn::after {
				content: '';
				position: absolute;
				bottom: -4px;
				left: 50%;
				width: 0;
				height: 2px;
				background: var(--accent);
				transition: all 0.3s ease;
				transform: translateX(-50%);
			}
			.sort-btn.active { color: var(--accent); }
			.sort-btn.active::after { width: 100%; }
			/* ‚ñ≤‚ñ≤‚ñ≤ „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÁµÇ ‚ñ≤‚ñ≤‚ñ≤ */

			ul {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
				gap: 2.5rem;
				list-style-type: none;
				padding: 0;
			}
			li {
				background: #fff;
				border-radius: 16px;
				overflow: hidden;
				transition: transform 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
			}
			li:hover { transform: translateY(-8px); }
			li a { display: block; text-decoration: none; color: inherit; }
			
			.hero-image {
				width: 100%;
				height: 220px;
				object-fit: cover;
				border-radius: 20px;
				margin-bottom: 1.2rem;
				box-shadow: 0 10px 30px rgba(0,0,0,0.06);
				border: 1px solid #f0f0f0;
			}
			.title { margin: 0 0 0.6rem 0; color: var(--text-main); line-height: 1.4; font-size: 1.3rem; font-weight: 800; }
			
			.post-meta {
				display: flex;
				align-items: center;
				gap: 12px;
				margin-top: 0.5rem;
				color: var(--text-sub);
				font-size: 0.85rem;
			}
			.date { margin: 0 !important; line-height: 1; }
			.like-badge {
				display: inline-flex;
				align-items: center;
				background: rgba(9, 132, 227, 0.08);
				color: var(--accent);
				padding: 2px 10px;
				border-radius: 8px;
				font-size: 0.8rem;
				font-weight: 800;
			}

			@media (max-width: 768px) {
				.blog-dashboard { padding: 1.5rem; }
				.sort-section { gap: 1rem; flex-direction: column; }
			}
		</style>
	</head>
	<body>
		<Header />
		<main>
			<div class="blog-dashboard">
				<nav class="category-nav">
					<a href="/blog/" class="cat-link">All Posts</a>
					{CATEGORIES.map((cat) => (
						<a href={`/blog/${cat.slug}`} class={`cat-link ${category === cat.slug ? 'active' : ''}`}>
							{cat.label}
						</a>
					))}
				</nav>

				<div class="search-container">
					<Search />
				</div>

				<div class="sort-section">
					<span class="sort-label">Order By</span>
					<div class="sort-options" id="sort-group">
						<button class="sort-btn active" data-sort="date-desc">Newest</button>
						<button class="sort-btn" data-sort="date-asc">Oldest</button>
						<button class="sort-btn" data-sort="likes-desc">Popular</button>
					</div>
				</div>
			</div>

			<ul id="post-list">
				{postsWithLikes.length > 0 ? (
					postsWithLikes.map((post) => (
						<li class="post-item" data-date={post.data.pubDate.valueOf()} data-likes={post.likeCount}>
							<a href={`/blog/${post.id}/`}>
								{post.data.heroImage && (
									<Image width={720} height={400} src={post.data.heroImage} alt="" class="hero-image" />
								)}
								<div style="padding: 0.5rem;">
									<h4 class="title">{post.data.title}</h4>
									<div class="post-meta">
										<p class="date">
											<FormattedDate date={post.data.pubDate} />
										</p>
										<span class="like-badge">üíô {post.likeCount} likes</span>
									</div>
								</div>
							</a>
						</li>
					))
				) : (
					<p style="text-align:center; grid-column: 1/-1;">„Åæ„Å†Ë®ò‰∫ã„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>
				)}
			</ul>
		</main>
		<Footer />

		<script is:inline define:vars={{ supabaseUrl, supabaseKey }}>
			const sortGroup = document.getElementById('sort-group');
			const buttons = sortGroup.querySelectorAll('.sort-btn');
			const list = document.getElementById('post-list');
			const items = Array.from(list.getElementsByClassName('post-item'));

			buttons.forEach(btn => {
				btn.addEventListener('click', () => {
					buttons.forEach(b => b.classList.remove('active'));
					btn.classList.add('active');
					const val = btn.dataset.sort;
					items.sort((a, b) => {
						if (val === 'date-desc') return parseInt(b.dataset.date) - parseInt(a.dataset.date);
						if (val === 'date-asc') return parseInt(a.dataset.date) - parseInt(b.dataset.date);
						if (val === 'likes-desc') return parseInt(b.dataset.likes) - parseInt(a.dataset.likes);
						return 0;
					});
					items.forEach(item => list.appendChild(item));
				});
			});

			async function refreshLikes() {
				try {
					const res = await fetch(`${supabaseUrl}/rest/v1/post_likes?select=slug,count`, {
						headers: { 'apikey': supabaseKey, 'Authorization': `Bearer ${supabaseKey}` }
					});
					const latestData = await res.json();
					items.forEach(item => {
						const link = item.querySelector('a');
						if (!link) return;
						const path = new URL(link.href).pathname;
						const match = latestData.find(l => l.slug === path);
						if (match) {
							const badge = item.querySelector('.like-badge');
							if (badge) badge.innerText = `üíô ${match.count} likes`;
							item.dataset.likes = match.count;
						}
					});
				} catch (e) { console.error(e); }
			}
			refreshLikes();
		</script>
	</body>
</html>